" vimrc
set nocompatible            " wyłączenie wstecznej kompatybilności z edytorem vi
let mapleader=' '    " ustawiona spacja jako klawisz leader
let localmapleader='\\'     " klawisz \ ustawiony jako local leader

call plug#begin('~/.vim/plugged')
    Plug 'gruvbox-community/gruvbox'
    Plug 'sainnhe/gruvbox-material'
    Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
    Plug 'junegunn/fzf.vim'
    Plug 'mbbill/undotree'
    Plug 'mhinz/vim-signify'
    Plug 'tpope/vim-fugitive'
    Plug 'vim-airline/vim-airline'
    Plug 'vim-airline/vim-airline-themes'
call plug#end()

syntax on
set number
set relativenumber
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
set wildmenu
set wildmode=list:longest,full
set foldmethod=marker
set splitright
set splitbelow
set backspace=indent,eol,start
set clipboard=unnamedplus
set hidden
set noshowmode
set nowrap
set smartcase
set incsearch
set undodir=~/.vim/undo
set undofile
set undolevels=10000
set laststatus=2
set scrolloff=5
set autochdir
setlocal spelllang=pl
set background=dark
colorscheme gruvbox
let g:gruvbox_contrast_dark='hard'
let g:gruvbox_invert_selection='0'
set termguicolors
if exists('+termguicolors')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif
let g:airline_theme='lucius'

nnoremap th :set hlsearch!<cr>
nnoremap j gj
nnoremap k gk
nnoremap gh 0
nnoremap gl $
nnoremap J maJ`a
nnoremap Y y$
nnoremap n nzz
nnoremap N Nzz
nnoremap qq :q<cr>
nnoremap qs :update<cr>:q<cr>

nnoremap <tab> :e #<cr>

cmap <c-h> <left>
cmap <c-j> <down>
cmap <c-k> <up>
cmap <c-l> <right>

inoremap <c-h> <left>
inoremap <c-j> <down>
inoremap <c-k> <up>
inoremap <c-l> <right>

inoremap <c-c> <esc>

nmap <c-h> <c-w><c-h>
nmap <c-j> <c-w><c-j>
nmap <c-k> <c-w><c-k>
nmap <c-l> <c-w><c-l>

nnoremap <leader>; :

" przechodzi do katalogu w którym znajduje się edytowany plik
nnoremap <leader>cd :cd %:p:h<cr>:pwd<cr>

" klonuje paragraf
nnoremap <leader>cp yap<S-}>p

nnoremap <leader>pa :set invpaste paste?<cr>

nnoremap <leader>v :e $MYVIMRC<cr>

nnoremap <leader>r :source $MYVIMRC<cr>echom "Konfiguracja została przeładowana ..."<cr>

nnoremap <leader>s :setlocal spell! spell? spelllang=pl<cr>

" otwera menadżer plików dla lokalizacji otwartego pliku
nnoremap <leader>f :sv %:p:h<cr>

nnoremap <leader>u :UndotreeToggle<cr>

nnoremap <leader>t :term<cr>
nnoremap <leader>tv :botright vertical terminal<cr>

" kopiuje bieżącą linię i uruchamia jako polecenie systemowe, wynik wkleja do
" bufora
nnoremap <leader>e !!$SHELL<cr>

" kopiuje bieżącą linię i wykonuje w linii komend Vim np. :qa!
nnoremap <leader>ve yy:@"<cr>

nnoremap <leader>n :exe "e ~/notes/".strftime("%F").".md"<cr>

" kopiuj / wklej do schowka systemowego
vnoremap <c-c> "*y :let @+=@*<cr>
nnoremap <c-c> "*y :let @+=@*<cr>
map <c-p> "+P

autocmd BufWinLeave ?* mkview
autocmd BufWinEnter ?* silent loadview

" przeładowanie .vimrc po zapisaniu pliku
autocmd! BufWritePost $MYVIMRC source % | redraw

" Modyfikacja komendy Rg z pluginem FZF.vim
" Przeszukiwanie zawartości plików
function! RipgrepFzf(query, fullscreen)
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s || true'
    let initial_command = printf(command_fmt, shellescape(a:query))
    let reload_command = printf(command_fmt, '{q}')
    let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
    call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

" Modyfikacja komendy Rg dla $NOTES_DIR z pluginem FZF.vim
" Przeszukiwanie zawartości plików
function! RipgrepFzfNotes(query, fullscreen)
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case %s $NOTES_DIR || true'
    let initial_command = printf(command_fmt, shellescape(a:query))
    let reload_command = printf(command_fmt, '{q}')
    let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
    call fzf#vim#grep(initial_command, 1, fzf#vim#with_preview(spec), a:fullscreen)
endfunction

function InsertLogEntry()
    normal! o# <temat> <data>
    execute ':s/<data>/\=strftime("%Y-%m-%d %H:%M:%S")/'
    normal! 0f<d7l
    execute ':startinsert'
endfunction

function! FileTime()
  let filename=expand('%:p')
  let msg=""
  let msg=msg."Mod: ".strftime("%F %T",getftime(filename))." ".filename
  echom msg
endfunction

function! CurTime()
  let ftime=""
  let ftime=ftime." ".strftime("Teraz jest: %F %T")
  echom ftime
  " return ftime
endfunction

" FZF z podglądem zawartości pliku
command! -bang -nargs=? -complete=dir Files
    \ call fzf#vim#files(<q-args>, fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline']}), <bang>0)

" FZF w $NOTES_DIR z podglądem zawartości pliku
command! -bang -nargs=? -complete=dir Notes
    \ call fzf#vim#files('$HOME/notes', fzf#vim#with_preview({'options': ['--layout=reverse', '--info=inline', '--prompt Notes']}), <bang>0)

command! -bang -nargs=* RgFzf call RipgrepFzf(<q-args>, <bang>0)

command! -bang -nargs=* RgFzfNotes call RipgrepFzfNotes(<q-args>, <bang>0)

" FZF bez podglądu zawartości pliku
command! -bang -nargs=* -complete=dir LS
    \ call fzf#run(fzf#wrap({'source': 'ls', 'dir': <q-args>}, <bang>0))

command! InsertLogEntry call InsertLogEntry()
command! Log :e ~/notes/log.md
command! FileTime call FileTime()
command! CurTime call CurTime()

